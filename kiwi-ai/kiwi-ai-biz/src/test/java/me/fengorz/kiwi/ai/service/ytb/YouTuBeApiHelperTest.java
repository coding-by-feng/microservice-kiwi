package me.fengorz.kiwi.ai.service.ytb;

import me.fengorz.kiwi.ai.api.vo.ytb.CaptionResponse;
import me.fengorz.kiwi.ai.api.vo.ytb.VideoDetailsResponse;
import me.fengorz.kiwi.common.sdk.exception.ServiceException;
import me.fengorz.kiwi.common.ytb.SubtitleTypeEnum;
import me.fengorz.kiwi.common.ytb.YtbSubtitlesResult;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;

/**
 * Unit tests for {@link YouTuBeApiHelper} covering caption selection, parsing and result building.
 */
public class YouTuBeApiHelperTest {

    private YouTubeApiService youTubeApiService;
    private YouTuBeApiHelper helper;

    @Before
    public void setUp() throws Exception {
        youTubeApiService = Mockito.mock(YouTubeApiService.class);
        helper = new YouTuBeApiHelper(youTubeApiService);
        // Set a default threshold high enough for small tests unless overridden
        setPrivateField(helper, "largeSubtitlesThreshold", 200);
        setPrivateField(helper, "subtitlesLangs", "en,en-US,en-GB");
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field f = target.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(target, value);
    }

    private CaptionResponse professionalCaption(String id, String lang) {
        return CaptionResponse.builder().id(id).language(lang).trackKind("standard").isAutoSynced(false).build();
    }

    private CaptionResponse autoGeneratedCaptionByTrackKind(String id, String lang) {
        return CaptionResponse.builder().id(id).language(lang).trackKind("asr").isAutoSynced(false).build();
    }

    private CaptionResponse autoGeneratedCaptionByFlag(String id, String lang) {
        return CaptionResponse.builder().id(id).language(lang).trackKind("standard").isAutoSynced(true).build();
    }

    private String buildCaptionContent(int segments, boolean duplicateText) {
        StringBuilder sb = new StringBuilder();
        sb.append("WEBVTT\n\n");
        for (int i = 0; i < segments; i++) {
            sb.append(i + 1).append("\n");
            // timestamp line (length < 50 and contains --> ) so parser will include it
            sb.append(String.format("00:00:%02d.000 --> 00:00:%02d.500\n", i, i));
            String text = duplicateText ? "SAME" : "Line_" + (i + 1);
            sb.append(text).append("\n\n");
        }
        // Add an intentional duplicate at end if duplicateText true to verify de-dup
        if (duplicateText) {
            sb.append(segments + 1).append("\n");
            sb.append(String.format("00:00:%02d.000 --> 00:00:%02d.500\n", segments, segments));
            sb.append("SAME\n");
        }
        return sb.toString();
    }

    @Test
    public void testDownloadSubtitlesProfessionalSmall() {
        String videoUrl = "https://youtu.be/abc12345678"; // 11-char id
        List<CaptionResponse> captions = Collections.singletonList(professionalCaption("c1", "en"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        String content = buildCaptionContent(2, false); // small
        when(youTubeApiService.downloadCaption("c1")).thenReturn(content);

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertNotNull(result);
        assertEquals(SubtitleTypeEnum.SMALL_PROFESSIONAL_RETURN_STRING, result.getType());
        assertTrue(result.getPendingToBeTranslatedOrRetouchedSubtitles() instanceof String);
        String pending = (String) result.getPendingToBeTranslatedOrRetouchedSubtitles();
        assertFalse("Pending subtitles should not contain timestamps", pending.contains(" --> "));
        assertEquals("en", result.getLangCode());
        assertTrue(result.getScrollingSubtitles().contains("00:00:00.000"));
    }

    @Test
    public void testDownloadSubtitlesProfessionalLarge() throws Exception {
        setPrivateField(helper, "largeSubtitlesThreshold", 2); // make threshold small
        String videoUrl = "https://youtu.be/abc12345679";
        List<CaptionResponse> captions = Collections.singletonList(professionalCaption("c2", "en"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        String content = buildCaptionContent(3, false); // exceeds threshold
        when(youTubeApiService.downloadCaption("c2")).thenReturn(content);

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertEquals(SubtitleTypeEnum.LARGE_PROFESSIONAL_RETURN_LIST, result.getType());
        assertTrue(result.getPendingToBeTranslatedOrRetouchedSubtitles() instanceof List);
        List<?> pending = (List<?>) result.getPendingToBeTranslatedOrRetouchedSubtitles();
        // Expect 3 text lines (timestamps removed). Each segment yields one text line
        assertEquals(3, pending.size());
    }

    @Test
    public void testDownloadSubtitlesAutoGeneratedSmallByTrackKind() throws Exception {
        setPrivateField(helper, "subtitlesLangs", "en");
        String videoUrl = "https://youtu.be/abc12345680";
        List<CaptionResponse> captions = Collections.singletonList(autoGeneratedCaptionByTrackKind("c3", "en"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        String content = buildCaptionContent(2, true); // duplicates
        when(youTubeApiService.downloadCaption("c3")).thenReturn(content);

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertEquals(SubtitleTypeEnum.SMALL_AUTO_GENERATED_RETURN_STRING, result.getType());
        assertTrue(result.getPendingToBeTranslatedOrRetouchedSubtitles() instanceof String);
        String scrolling = result.getScrollingSubtitles();
        // Ensure duplicate text appears only once in scrolling subtitles (distinct in cleaner)
        int occurrences = countOccurrences(scrolling, "SAME\n");
        assertEquals("Duplicate lines should be cleaned", 1, occurrences);
    }

    @Test
    public void testDownloadSubtitlesAutoGeneratedLargeByAutoSynced() throws Exception {
        setPrivateField(helper, "largeSubtitlesThreshold", 2);
        String videoUrl = "https://youtu.be/abc12345681";
        List<CaptionResponse> captions = Collections.singletonList(autoGeneratedCaptionByFlag("c4", "en"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        String content = buildCaptionContent(3, false);
        when(youTubeApiService.downloadCaption("c4")).thenReturn(content);

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertEquals(SubtitleTypeEnum.LARGE_AUTO_GENERATED_RETURN_LIST, result.getType());
        assertTrue(result.getPendingToBeTranslatedOrRetouchedSubtitles() instanceof List);
    }

    @Test
    public void testLanguageSelectionPreferredOrder() throws Exception {
        setPrivateField(helper, "subtitlesLangs", "en-US,en");
        String videoUrl = "https://youtu.be/abc12345682";
        // Intentionally order captions with en first, but expect en-US selected due to preference config
        List<CaptionResponse> captions = Arrays.asList(professionalCaption("c5", "en"), professionalCaption("c6", "en-US"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        when(youTubeApiService.downloadCaption("c6")).thenReturn(buildCaptionContent(1, false));

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertEquals("en-US", result.getLangCode());
    }

    @Test
    public void testLanguageSelectionFallbackToFirst() throws Exception {
        setPrivateField(helper, "subtitlesLangs", "fr,de");
        String videoUrl = "https://youtu.be/abc12345683";
        List<CaptionResponse> captions = Arrays.asList(professionalCaption("c7", "jp"), professionalCaption("c8", "ru"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        when(youTubeApiService.downloadCaption("c7")).thenReturn(buildCaptionContent(1, false));

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertEquals("jp", result.getLangCode());
    }

    @Test
    public void testDefaultLanguageWhenBlank() throws Exception {
        setPrivateField(helper, "subtitlesLangs", "zz"); // ensure no match so fallback
        String videoUrl = "https://youtu.be/abc12345684";
        CaptionResponse blankLang = professionalCaption("c9", "");
        List<CaptionResponse> captions = Collections.singletonList(blankLang);
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        when(youTubeApiService.downloadCaption("c9")).thenReturn(buildCaptionContent(1, false));

        YtbSubtitlesResult result = helper.downloadSubtitles(videoUrl);
        assertEquals("en", result.getLangCode()); // defaultIfBlank logic
    }

    @Test(expected = ServiceException.class)
    public void testNoCaptionsThrows() {
        String videoUrl = "https://youtu.be/abc12345685";
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(Collections.emptyList());
        helper.downloadSubtitles(videoUrl);
    }

    @Test(expected = ServiceException.class)
    public void testEmptyCaptionContentThrows() {
        String videoUrl = "https://youtu.be/abc12345686";
        List<CaptionResponse> captions = Collections.singletonList(professionalCaption("c10", "en"));
        when(youTubeApiService.getVideoCaptions(videoUrl)).thenReturn(captions);
        when(youTubeApiService.downloadCaption("c10")).thenReturn("   ");
        helper.downloadSubtitles(videoUrl);
    }

    @Test
    public void testGetVideoTitle() {
        String videoUrl = "https://youtu.be/abc12345687";
        when(youTubeApiService.getVideoDetails(videoUrl)).thenReturn(VideoDetailsResponse.builder().title("My Title").build());
        String title = helper.getVideoTitle(videoUrl);
        assertEquals("My Title", title);
    }

    private int countOccurrences(String haystack, String needle) {
        int count = 0;
        int index = 0;
        while ((index = haystack.indexOf(needle, index)) != -1) {
            count++;
            index += needle.length();
        }
        return count;
    }
}
